<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stream.stream API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stream.stream</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import cmp_to_key
import random

from .util.iterators import IteratorUtils
from .util.optional import Optional


class Stream():

    &#34;&#34;&#34;
    A sequence of elements supporting sequential operations.

    The following example illustrates an aggregate operation using
    Stream:

        result = Stream(elements)
                        .filter(lambda w: w.getColor() == RED)
                        .map(lambda w: w.getWeight())
                        .sum()

    A stream pipeline, like the elements example above, can be viewed as a query on the stream source.

    A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, &#34;forked&#34; streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may raise Exception if it detects that the stream is being reused.
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    Static Methods
    &#34;&#34;&#34;

    @staticmethod
    def empty():
        &#39;&#39;&#39;
        Returns an empty sequential Stream.

        :return: an empty sequential stream
        &#39;&#39;&#39;
        return Stream([])

    @staticmethod
    def of(elem):
        &#39;&#39;&#39;
        Returns a sequential Stream containing a single element.

        :param T elem: the single element
        :return: a singleton sequential stream
        &#39;&#39;&#39;
        return Stream(iter([elem]))

    @staticmethod
    def of(*elements):
        &#39;&#39;&#39;
        Returns a sequential ordered stream whose elements are the specified values.

        :param *T elements: the elements of the new stream
        :return: the new stream
        &#39;&#39;&#39;
        return Stream(iter(list(elements)))

    @staticmethod
    def ofNullable(elem):
        &#39;&#39;&#39;
        Returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.

        :param T elem: the single element
        :return: a stream with a single element if the specified element is non-null, otherwise an empty stream
        &#39;&#39;&#39;
        return Stream.of(elem) if elem is not None else Stream.empty()

    @staticmethod
    def iterate(seed, operator):
        &#39;&#39;&#39;
        Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.

        :param T seed: the initial element
        :param UnaryOperator operator: a function to be applied to the previous element to produce a new element
        :return: a new sequential Stream
        &#39;&#39;&#39;
        return Stream(IteratorUtils.iterate(seed, operator))

    @staticmethod
    def generate(supplier):
        &#39;&#39;&#39;
        Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.

        :param Supplier supplier: the Supplier of generated elements
        :return: a new infinite sequential unordered Stream
        &#39;&#39;&#39;
        return Stream(IteratorUtils.generate(supplier))

    @staticmethod
    def concat(*streams):
        &#39;&#39;&#39;
        Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream and so on.

        :param *Stream streams: the streams to concat
        :return: the concatenation of the input streams
        &#39;&#39;&#39;
        return Stream(IteratorUtils.concat(*streams))

    @staticmethod
    def constant(element):
        &#39;&#39;&#39;
        Return an infinite sequential stream where each element is the passed element

        :param T elem: the element
        :return: the new stream made of @element
        &#39;&#39;&#39;
        return Stream.generate(lambda: element)

    &#34;&#34;&#34;
    Normal Methods
    &#34;&#34;&#34;

    def __init__(self, iterable):
        self.iterable = iterable

    def filter(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

        :param function predicate: predicate to apply to each element to determine if it should be included
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.filter(self.iterable, predicate)
        return self

    def map(self, mapper):
        &#39;&#39;&#39;
        Returns a stream consisting of the results of applying the given function to the elements of this stream.

        :param function mapper: function to apply to each element
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.map(self.iterable, mapper)
        return self

    def flatMap(self, flatMapper):
        &#39;&#39;&#39;
        Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)

        :param function flatMapper: function to apply to each element which produces a stream of new values
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.flatMap(self.iterable, flatMapper)
        return self

    def distinct(self):
        &#39;&#39;&#39;
        Returns a stream consisting of the distinct elements of this stream.

        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.distinct(self.iterable)
        return self

    def limit(self, count):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.

        :param int count:  the number of elements the stream should be limited to
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.limit(self.iterable, count)
        return self

    def skip(self, count):
        &#39;&#39;&#39;
        Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned.

        :param int count:  the number of leading elements to skip
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.skip(self.iterable, count)
        return self

    def takeWhile(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the longest prefix of elements taken from this stream that match the given predicate.

        :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.takeWhile(self.iterable, predicate)
        return self

    def dropWhile(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate.

        :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.dropWhile(self.iterable, predicate)
        return self

    &#34;&#34;&#34;
    From here this method mustn&#39;t be called on infinite stream
    &#34;&#34;&#34;

    def sorted(self, comparator=None):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.

        :param Comparator comparator: Comparator to be used to compare stream elements - if null default comparator is used
        :return: self
        &#39;&#39;&#39;
        self.iterable = iter(sorted(
            self.iterable, key=cmp_to_key(comparator))) if comparator is not None else iter(sorted(
                self.iterable))
        return self

    def peek(self, consumer):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

        :param Consumer consumer: action to perform on the elements as they are consumed from the stream
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.peek(self.iterable, consumer)
        return self

    def forEach(self, function):
        &#39;&#39;&#39;
        Performs an action for each element of this stream.

        :param Function function: action to perform on the elements
        :return: None
        &#39;&#39;&#39;
        for elem in self.iterable:
            function(elem)

    def anyMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether any elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if any elements of the stream match the provided predicate, otherwise False
        &#39;&#39;&#39;
        return any([predicate(elem) for elem in self.iterable])

    def allMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether all elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if either all elements of the stream match the provided predicate or the stream is empty, otherwise False
        &#39;&#39;&#39;
        return all([predicate(elem) for elem in self.iterable])

    def noneMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether no elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if either no elements of the stream match the provided predicate or the stream is empty, otherwise False
        &#39;&#39;&#39;
        return not self.anyMatch(predicate)

    def findFirst(self, predicate=None):
        &#39;&#39;&#39;
        Returns an Optional describing the first element (with optional filtering by a given predicate) of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.

        :param Predicate predicate: optional predicate to apply to elements of this stream
        :return: an Optional describing the first element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        if predicate:
            self.filter(predicate)

        for elem in self.iterable:
            return Optional.of(elem)
        return Optional.ofNullable(None)

    def findAny(self):
        &#39;&#39;&#39;
        Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.

        :return: an Optional describing some element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        return self.findFirst()

    def reduce(self, accumulator, identity=None):
        &#39;&#39;&#39;
        Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.

        :param T identity: the identity value for the accumulating function - if not specified it will be the first element of the stream
        :param Accumulator accumulator: function for combining two values
        :return: the result of reduction
        &#39;&#39;&#39;
        result = identity
        for elem in self.iterable:
            if(result is None):
                result = elem
            else:
                result = accumulator(result, elem)
        return Optional.ofNullable(result)

    def min(self, comparator=None):
        &#39;&#39;&#39;
        Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction.

        :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
        :return: an Optional describing the minimum element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        elements = list(self.iterable)
        if len(elements) == 0:
            return Optional.empty()

        return Optional.ofNullable(min(elements, key=cmp_to_key(comparator), default=None)) if comparator is not None else Optional.ofNullable(min(elements, default=None))

    def max(self, comparator=None):
        &#39;&#39;&#39;
        Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction.

        :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
        :return: an Optional describing the maximum element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        elements = list(self.iterable)
        if len(elements) == 0:
            return Optional.empty()
        return Optional.ofNullable(max(elements, key=cmp_to_key(comparator))) if comparator is not None else Optional.ofNullable(max(elements))

    def sum(self):
        &#39;&#39;&#39;
        Returns the sum of all elements of this stream. This is a special case of a reduction.

        :return: an Optional describing the sum of all the elements of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        return self.reduce(lambda x, y: x + y)

    def count(self):
        &#39;&#39;&#39;
        Returns the count of elements in this stream. This is a special case of a reduction.

        :return: the count of elements in this stream
        &#39;&#39;&#39;
        count = 0
        for elem in self.iterable:
            count += 1

        return count

    def toList(self):
        &#39;&#39;&#39;
        Returns a list with the elements in this stream.

        :return: the list of elements in this stream
        &#39;&#39;&#39;
        return list(self.iterable)

    def toSet(self):
        &#39;&#39;&#39;
        Returns a set with the elements in this stream.

        :return: the set of elements in this stream
        &#39;&#39;&#39;
        return set(self.iterable)

    def toNumberStream(self):
        from .numbers import NumberStream
        return NumberStream(self)

    def toBooleanStream(self):
        from .booleans import BooleanStream
        return BooleanStream(self)

    def __iter__(self):
        &#39;&#39;&#39;
        Returns an iterator over the elements in this stream.

        :return: the iterator over the elements in this stream
        &#39;&#39;&#39;
        return iter(self.iterable)

    def __eq__(self, value):
        &#39;&#39;&#39;
        Check if this stream is equal to the specified stream

        :return: True if the streams match, False otherwise
        &#39;&#39;&#39;
        return self.toSet() == value.toSet()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stream.stream.Stream"><code class="flex name class">
<span>class <span class="ident">Stream</span></span>
<span>(</span><span>iterable)</span>
</code></dt>
<dd>
<div class="desc"><p>A sequence of elements supporting sequential operations.</p>
<p>The following example illustrates an aggregate operation using</p>
<h2 id="stream">Stream</h2>
<p>result = Stream(elements)
.filter(lambda w: w.getColor() == RED)
.map(lambda w: w.getWeight())
.sum()</p>
<p>A stream pipeline, like the elements example above, can be viewed as a query on the stream source.</p>
<p>A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, "forked" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may raise Exception if it detects that the stream is being reused.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stream():

    &#34;&#34;&#34;
    A sequence of elements supporting sequential operations.

    The following example illustrates an aggregate operation using
    Stream:

        result = Stream(elements)
                        .filter(lambda w: w.getColor() == RED)
                        .map(lambda w: w.getWeight())
                        .sum()

    A stream pipeline, like the elements example above, can be viewed as a query on the stream source.

    A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, &#34;forked&#34; streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may raise Exception if it detects that the stream is being reused.
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    Static Methods
    &#34;&#34;&#34;

    @staticmethod
    def empty():
        &#39;&#39;&#39;
        Returns an empty sequential Stream.

        :return: an empty sequential stream
        &#39;&#39;&#39;
        return Stream([])

    @staticmethod
    def of(elem):
        &#39;&#39;&#39;
        Returns a sequential Stream containing a single element.

        :param T elem: the single element
        :return: a singleton sequential stream
        &#39;&#39;&#39;
        return Stream(iter([elem]))

    @staticmethod
    def of(*elements):
        &#39;&#39;&#39;
        Returns a sequential ordered stream whose elements are the specified values.

        :param *T elements: the elements of the new stream
        :return: the new stream
        &#39;&#39;&#39;
        return Stream(iter(list(elements)))

    @staticmethod
    def ofNullable(elem):
        &#39;&#39;&#39;
        Returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.

        :param T elem: the single element
        :return: a stream with a single element if the specified element is non-null, otherwise an empty stream
        &#39;&#39;&#39;
        return Stream.of(elem) if elem is not None else Stream.empty()

    @staticmethod
    def iterate(seed, operator):
        &#39;&#39;&#39;
        Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.

        :param T seed: the initial element
        :param UnaryOperator operator: a function to be applied to the previous element to produce a new element
        :return: a new sequential Stream
        &#39;&#39;&#39;
        return Stream(IteratorUtils.iterate(seed, operator))

    @staticmethod
    def generate(supplier):
        &#39;&#39;&#39;
        Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.

        :param Supplier supplier: the Supplier of generated elements
        :return: a new infinite sequential unordered Stream
        &#39;&#39;&#39;
        return Stream(IteratorUtils.generate(supplier))

    @staticmethod
    def concat(*streams):
        &#39;&#39;&#39;
        Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream and so on.

        :param *Stream streams: the streams to concat
        :return: the concatenation of the input streams
        &#39;&#39;&#39;
        return Stream(IteratorUtils.concat(*streams))

    @staticmethod
    def constant(element):
        &#39;&#39;&#39;
        Return an infinite sequential stream where each element is the passed element

        :param T elem: the element
        :return: the new stream made of @element
        &#39;&#39;&#39;
        return Stream.generate(lambda: element)

    &#34;&#34;&#34;
    Normal Methods
    &#34;&#34;&#34;

    def __init__(self, iterable):
        self.iterable = iterable

    def filter(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

        :param function predicate: predicate to apply to each element to determine if it should be included
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.filter(self.iterable, predicate)
        return self

    def map(self, mapper):
        &#39;&#39;&#39;
        Returns a stream consisting of the results of applying the given function to the elements of this stream.

        :param function mapper: function to apply to each element
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.map(self.iterable, mapper)
        return self

    def flatMap(self, flatMapper):
        &#39;&#39;&#39;
        Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)

        :param function flatMapper: function to apply to each element which produces a stream of new values
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.flatMap(self.iterable, flatMapper)
        return self

    def distinct(self):
        &#39;&#39;&#39;
        Returns a stream consisting of the distinct elements of this stream.

        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.distinct(self.iterable)
        return self

    def limit(self, count):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.

        :param int count:  the number of elements the stream should be limited to
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.limit(self.iterable, count)
        return self

    def skip(self, count):
        &#39;&#39;&#39;
        Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned.

        :param int count:  the number of leading elements to skip
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.skip(self.iterable, count)
        return self

    def takeWhile(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the longest prefix of elements taken from this stream that match the given predicate.

        :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.takeWhile(self.iterable, predicate)
        return self

    def dropWhile(self, predicate):
        &#39;&#39;&#39;
        Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate.

        :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.dropWhile(self.iterable, predicate)
        return self

    &#34;&#34;&#34;
    From here this method mustn&#39;t be called on infinite stream
    &#34;&#34;&#34;

    def sorted(self, comparator=None):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.

        :param Comparator comparator: Comparator to be used to compare stream elements - if null default comparator is used
        :return: self
        &#39;&#39;&#39;
        self.iterable = iter(sorted(
            self.iterable, key=cmp_to_key(comparator))) if comparator is not None else iter(sorted(
                self.iterable))
        return self

    def peek(self, consumer):
        &#39;&#39;&#39;
        Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

        :param Consumer consumer: action to perform on the elements as they are consumed from the stream
        :return: self
        &#39;&#39;&#39;
        self.iterable = IteratorUtils.peek(self.iterable, consumer)
        return self

    def forEach(self, function):
        &#39;&#39;&#39;
        Performs an action for each element of this stream.

        :param Function function: action to perform on the elements
        :return: None
        &#39;&#39;&#39;
        for elem in self.iterable:
            function(elem)

    def anyMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether any elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if any elements of the stream match the provided predicate, otherwise False
        &#39;&#39;&#39;
        return any([predicate(elem) for elem in self.iterable])

    def allMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether all elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if either all elements of the stream match the provided predicate or the stream is empty, otherwise False
        &#39;&#39;&#39;
        return all([predicate(elem) for elem in self.iterable])

    def noneMatch(self, predicate):
        &#39;&#39;&#39;
        Returns whether no elements of this stream match the provided predicate.

        :param Predicate predicate: predicate to apply to elements of this stream
        :return: True if either no elements of the stream match the provided predicate or the stream is empty, otherwise False
        &#39;&#39;&#39;
        return not self.anyMatch(predicate)

    def findFirst(self, predicate=None):
        &#39;&#39;&#39;
        Returns an Optional describing the first element (with optional filtering by a given predicate) of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.

        :param Predicate predicate: optional predicate to apply to elements of this stream
        :return: an Optional describing the first element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        if predicate:
            self.filter(predicate)

        for elem in self.iterable:
            return Optional.of(elem)
        return Optional.ofNullable(None)

    def findAny(self):
        &#39;&#39;&#39;
        Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.

        :return: an Optional describing some element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        return self.findFirst()

    def reduce(self, accumulator, identity=None):
        &#39;&#39;&#39;
        Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.

        :param T identity: the identity value for the accumulating function - if not specified it will be the first element of the stream
        :param Accumulator accumulator: function for combining two values
        :return: the result of reduction
        &#39;&#39;&#39;
        result = identity
        for elem in self.iterable:
            if(result is None):
                result = elem
            else:
                result = accumulator(result, elem)
        return Optional.ofNullable(result)

    def min(self, comparator=None):
        &#39;&#39;&#39;
        Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction.

        :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
        :return: an Optional describing the minimum element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        elements = list(self.iterable)
        if len(elements) == 0:
            return Optional.empty()

        return Optional.ofNullable(min(elements, key=cmp_to_key(comparator), default=None)) if comparator is not None else Optional.ofNullable(min(elements, default=None))

    def max(self, comparator=None):
        &#39;&#39;&#39;
        Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction.

        :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
        :return: an Optional describing the maximum element of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        elements = list(self.iterable)
        if len(elements) == 0:
            return Optional.empty()
        return Optional.ofNullable(max(elements, key=cmp_to_key(comparator))) if comparator is not None else Optional.ofNullable(max(elements))

    def sum(self):
        &#39;&#39;&#39;
        Returns the sum of all elements of this stream. This is a special case of a reduction.

        :return: an Optional describing the sum of all the elements of this stream, or an empty Optional if the stream is empty
        &#39;&#39;&#39;
        return self.reduce(lambda x, y: x + y)

    def count(self):
        &#39;&#39;&#39;
        Returns the count of elements in this stream. This is a special case of a reduction.

        :return: the count of elements in this stream
        &#39;&#39;&#39;
        count = 0
        for elem in self.iterable:
            count += 1

        return count

    def toList(self):
        &#39;&#39;&#39;
        Returns a list with the elements in this stream.

        :return: the list of elements in this stream
        &#39;&#39;&#39;
        return list(self.iterable)

    def toSet(self):
        &#39;&#39;&#39;
        Returns a set with the elements in this stream.

        :return: the set of elements in this stream
        &#39;&#39;&#39;
        return set(self.iterable)

    def toNumberStream(self):
        from .numbers import NumberStream
        return NumberStream(self)

    def toBooleanStream(self):
        from .booleans import BooleanStream
        return BooleanStream(self)

    def __iter__(self):
        &#39;&#39;&#39;
        Returns an iterator over the elements in this stream.

        :return: the iterator over the elements in this stream
        &#39;&#39;&#39;
        return iter(self.iterable)

    def __eq__(self, value):
        &#39;&#39;&#39;
        Check if this stream is equal to the specified stream

        :return: True if the streams match, False otherwise
        &#39;&#39;&#39;
        return self.toSet() == value.toSet()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stream.booleans.BooleanStream" href="booleans.html#stream.booleans.BooleanStream">BooleanStream</a></li>
<li><a title="stream.numbers.NumberStream" href="numbers.html#stream.numbers.NumberStream">NumberStream</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="stream.stream.Stream.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>*streams)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream and so on.</p>
<p>:param *Stream streams: the streams to concat
:return: the concatenation of the input streams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def concat(*streams):
    &#39;&#39;&#39;
    Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream and so on.

    :param *Stream streams: the streams to concat
    :return: the concatenation of the input streams
    &#39;&#39;&#39;
    return Stream(IteratorUtils.concat(*streams))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.constant"><code class="name flex">
<span>def <span class="ident">constant</span></span>(<span>element)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an infinite sequential stream where each element is the passed element</p>
<p>:param T elem: the element
:return: the new stream made of @element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def constant(element):
    &#39;&#39;&#39;
    Return an infinite sequential stream where each element is the passed element

    :param T elem: the element
    :return: the new stream made of @element
    &#39;&#39;&#39;
    return Stream.generate(lambda: element)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an empty sequential Stream.</p>
<p>:return: an empty sequential stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def empty():
    &#39;&#39;&#39;
    Returns an empty sequential Stream.

    :return: an empty sequential stream
    &#39;&#39;&#39;
    return Stream([])</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>supplier)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.</p>
<p>:param Supplier supplier: the Supplier of generated elements
:return: a new infinite sequential unordered Stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def generate(supplier):
    &#39;&#39;&#39;
    Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.

    :param Supplier supplier: the Supplier of generated elements
    :return: a new infinite sequential unordered Stream
    &#39;&#39;&#39;
    return Stream(IteratorUtils.generate(supplier))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.iterate"><code class="name flex">
<span>def <span class="ident">iterate</span></span>(<span>seed, operator)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.</p>
<p>:param T seed: the initial element
:param UnaryOperator operator: a function to be applied to the previous element to produce a new element
:return: a new sequential Stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def iterate(seed, operator):
    &#39;&#39;&#39;
    Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.

    :param T seed: the initial element
    :param UnaryOperator operator: a function to be applied to the previous element to produce a new element
    :return: a new sequential Stream
    &#39;&#39;&#39;
    return Stream(IteratorUtils.iterate(seed, operator))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>*elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequential ordered stream whose elements are the specified values.</p>
<p>:param *T elements: the elements of the new stream
:return: the new stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def of(*elements):
    &#39;&#39;&#39;
    Returns a sequential ordered stream whose elements are the specified values.

    :param *T elements: the elements of the new stream
    :return: the new stream
    &#39;&#39;&#39;
    return Stream(iter(list(elements)))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.ofNullable"><code class="name flex">
<span>def <span class="ident">ofNullable</span></span>(<span>elem)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.</p>
<p>:param T elem: the single element
:return: a stream with a single element if the specified element is non-null, otherwise an empty stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def ofNullable(elem):
    &#39;&#39;&#39;
    Returns a sequential Stream containing a single element, if non-null, otherwise returns an empty Stream.

    :param T elem: the single element
    :return: a stream with a single element if the specified element is non-null, otherwise an empty stream
    &#39;&#39;&#39;
    return Stream.of(elem) if elem is not None else Stream.empty()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stream.stream.Stream.allMatch"><code class="name flex">
<span>def <span class="ident">allMatch</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether all elements of this stream match the provided predicate.</p>
<p>:param Predicate predicate: predicate to apply to elements of this stream
:return: True if either all elements of the stream match the provided predicate or the stream is empty, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allMatch(self, predicate):
    &#39;&#39;&#39;
    Returns whether all elements of this stream match the provided predicate.

    :param Predicate predicate: predicate to apply to elements of this stream
    :return: True if either all elements of the stream match the provided predicate or the stream is empty, otherwise False
    &#39;&#39;&#39;
    return all([predicate(elem) for elem in self.iterable])</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.anyMatch"><code class="name flex">
<span>def <span class="ident">anyMatch</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether any elements of this stream match the provided predicate.</p>
<p>:param Predicate predicate: predicate to apply to elements of this stream
:return: True if any elements of the stream match the provided predicate, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def anyMatch(self, predicate):
    &#39;&#39;&#39;
    Returns whether any elements of this stream match the provided predicate.

    :param Predicate predicate: predicate to apply to elements of this stream
    :return: True if any elements of the stream match the provided predicate, otherwise False
    &#39;&#39;&#39;
    return any([predicate(elem) for elem in self.iterable])</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the count of elements in this stream. This is a special case of a reduction.</p>
<p>:return: the count of elements in this stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self):
    &#39;&#39;&#39;
    Returns the count of elements in this stream. This is a special case of a reduction.

    :return: the count of elements in this stream
    &#39;&#39;&#39;
    count = 0
    for elem in self.iterable:
        count += 1

    return count</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.distinct"><code class="name flex">
<span>def <span class="ident">distinct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the distinct elements of this stream.</p>
<p>:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distinct(self):
    &#39;&#39;&#39;
    Returns a stream consisting of the distinct elements of this stream.

    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.distinct(self.iterable)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.dropWhile"><code class="name flex">
<span>def <span class="ident">dropWhile</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate.</p>
<p>:param Predicate predicate:
predicate to apply to elements to determine the longest prefix of elements.
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dropWhile(self, predicate):
    &#39;&#39;&#39;
    Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix of elements that match the given predicate.

    :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.dropWhile(self.iterable, predicate)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</p>
<p>:param function predicate: predicate to apply to each element to determine if it should be included
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, predicate):
    &#39;&#39;&#39;
    Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

    :param function predicate: predicate to apply to each element to determine if it should be included
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.filter(self.iterable, predicate)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.findAny"><code class="name flex">
<span>def <span class="ident">findAny</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.</p>
<p>:return: an Optional describing some element of this stream, or an empty Optional if the stream is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findAny(self):
    &#39;&#39;&#39;
    Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.

    :return: an Optional describing some element of this stream, or an empty Optional if the stream is empty
    &#39;&#39;&#39;
    return self.findFirst()</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.findFirst"><code class="name flex">
<span>def <span class="ident">findFirst</span></span>(<span>self, predicate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an Optional describing the first element (with optional filtering by a given predicate) of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.</p>
<p>:param Predicate predicate: optional predicate to apply to elements of this stream
:return: an Optional describing the first element of this stream, or an empty Optional if the stream is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findFirst(self, predicate=None):
    &#39;&#39;&#39;
    Returns an Optional describing the first element (with optional filtering by a given predicate) of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.

    :param Predicate predicate: optional predicate to apply to elements of this stream
    :return: an Optional describing the first element of this stream, or an empty Optional if the stream is empty
    &#39;&#39;&#39;
    if predicate:
        self.filter(predicate)

    for elem in self.iterable:
        return Optional.of(elem)
    return Optional.ofNullable(None)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.flatMap"><code class="name flex">
<span>def <span class="ident">flatMap</span></span>(<span>self, flatMapper)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)</p>
<p>:param function flatMapper: function to apply to each element which produces a stream of new values
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatMap(self, flatMapper):
    &#39;&#39;&#39;
    Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)

    :param function flatMapper: function to apply to each element which produces a stream of new values
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.flatMap(self.iterable, flatMapper)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.forEach"><code class="name flex">
<span>def <span class="ident">forEach</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs an action for each element of this stream.</p>
<p>:param Function function: action to perform on the elements
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forEach(self, function):
    &#39;&#39;&#39;
    Performs an action for each element of this stream.

    :param Function function: action to perform on the elements
    :return: None
    &#39;&#39;&#39;
    for elem in self.iterable:
        function(elem)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.limit"><code class="name flex">
<span>def <span class="ident">limit</span></span>(<span>self, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</p>
<p>:param int count:
the number of elements the stream should be limited to
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limit(self, count):
    &#39;&#39;&#39;
    Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.

    :param int count:  the number of elements the stream should be limited to
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.limit(self.iterable, count)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, mapper)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the results of applying the given function to the elements of this stream.</p>
<p>:param function mapper: function to apply to each element
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, mapper):
    &#39;&#39;&#39;
    Returns a stream consisting of the results of applying the given function to the elements of this stream.

    :param function mapper: function to apply to each element
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.map(self.iterable, mapper)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>self, comparator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction.</p>
<p>:param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
:return: an Optional describing the maximum element of this stream, or an empty Optional if the stream is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(self, comparator=None):
    &#39;&#39;&#39;
    Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction.

    :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
    :return: an Optional describing the maximum element of this stream, or an empty Optional if the stream is empty
    &#39;&#39;&#39;
    elements = list(self.iterable)
    if len(elements) == 0:
        return Optional.empty()
    return Optional.ofNullable(max(elements, key=cmp_to_key(comparator))) if comparator is not None else Optional.ofNullable(max(elements))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>self, comparator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction.</p>
<p>:param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
:return: an Optional describing the minimum element of this stream, or an empty Optional if the stream is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(self, comparator=None):
    &#39;&#39;&#39;
    Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction.

    :param Comparator comparator: Comparator to compare elements of this stream - if null default comparator is used
    :return: an Optional describing the minimum element of this stream, or an empty Optional if the stream is empty
    &#39;&#39;&#39;
    elements = list(self.iterable)
    if len(elements) == 0:
        return Optional.empty()

    return Optional.ofNullable(min(elements, key=cmp_to_key(comparator), default=None)) if comparator is not None else Optional.ofNullable(min(elements, default=None))</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.noneMatch"><code class="name flex">
<span>def <span class="ident">noneMatch</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether no elements of this stream match the provided predicate.</p>
<p>:param Predicate predicate: predicate to apply to elements of this stream
:return: True if either no elements of the stream match the provided predicate or the stream is empty, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def noneMatch(self, predicate):
    &#39;&#39;&#39;
    Returns whether no elements of this stream match the provided predicate.

    :param Predicate predicate: predicate to apply to elements of this stream
    :return: True if either no elements of the stream match the provided predicate or the stream is empty, otherwise False
    &#39;&#39;&#39;
    return not self.anyMatch(predicate)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, consumer)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.</p>
<p>:param Consumer consumer: action to perform on the elements as they are consumed from the stream
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self, consumer):
    &#39;&#39;&#39;
    Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream.

    :param Consumer consumer: action to perform on the elements as they are consumed from the stream
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.peek(self.iterable, consumer)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, accumulator, identity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.</p>
<p>:param T identity: the identity value for the accumulating function - if not specified it will be the first element of the stream
:param Accumulator accumulator: function for combining two values
:return: the result of reduction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, accumulator, identity=None):
    &#39;&#39;&#39;
    Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value.

    :param T identity: the identity value for the accumulating function - if not specified it will be the first element of the stream
    :param Accumulator accumulator: function for combining two values
    :return: the result of reduction
    &#39;&#39;&#39;
    result = identity
    for elem in self.iterable:
        if(result is None):
            result = elem
        else:
            result = accumulator(result, elem)
    return Optional.ofNullable(result)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned.</p>
<p>:param int count:
the number of leading elements to skip
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, count):
    &#39;&#39;&#39;
    Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned.

    :param int count:  the number of leading elements to skip
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.skip(self.iterable, count)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.sorted"><code class="name flex">
<span>def <span class="ident">sorted</span></span>(<span>self, comparator=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.</p>
<p>:param Comparator comparator: Comparator to be used to compare stream elements - if null default comparator is used
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted(self, comparator=None):
    &#39;&#39;&#39;
    Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator.

    :param Comparator comparator: Comparator to be used to compare stream elements - if null default comparator is used
    :return: self
    &#39;&#39;&#39;
    self.iterable = iter(sorted(
        self.iterable, key=cmp_to_key(comparator))) if comparator is not None else iter(sorted(
            self.iterable))
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sum of all elements of this stream. This is a special case of a reduction.</p>
<p>:return: an Optional describing the sum of all the elements of this stream, or an empty Optional if the stream is empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self):
    &#39;&#39;&#39;
    Returns the sum of all elements of this stream. This is a special case of a reduction.

    :return: an Optional describing the sum of all the elements of this stream, or an empty Optional if the stream is empty
    &#39;&#39;&#39;
    return self.reduce(lambda x, y: x + y)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.takeWhile"><code class="name flex">
<span>def <span class="ident">takeWhile</span></span>(<span>self, predicate)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a stream consisting of the longest prefix of elements taken from this stream that match the given predicate.</p>
<p>:param Predicate predicate:
predicate to apply to elements to determine the longest prefix of elements.
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def takeWhile(self, predicate):
    &#39;&#39;&#39;
    Returns a stream consisting of the longest prefix of elements taken from this stream that match the given predicate.

    :param Predicate predicate:  predicate to apply to elements to determine the longest prefix of elements.
    :return: self
    &#39;&#39;&#39;
    self.iterable = IteratorUtils.takeWhile(self.iterable, predicate)
    return self</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.toBooleanStream"><code class="name flex">
<span>def <span class="ident">toBooleanStream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toBooleanStream(self):
    from .booleans import BooleanStream
    return BooleanStream(self)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.toList"><code class="name flex">
<span>def <span class="ident">toList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list with the elements in this stream.</p>
<p>:return: the list of elements in this stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toList(self):
    &#39;&#39;&#39;
    Returns a list with the elements in this stream.

    :return: the list of elements in this stream
    &#39;&#39;&#39;
    return list(self.iterable)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.toNumberStream"><code class="name flex">
<span>def <span class="ident">toNumberStream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toNumberStream(self):
    from .numbers import NumberStream
    return NumberStream(self)</code></pre>
</details>
</dd>
<dt id="stream.stream.Stream.toSet"><code class="name flex">
<span>def <span class="ident">toSet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a set with the elements in this stream.</p>
<p>:return: the set of elements in this stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toSet(self):
    &#39;&#39;&#39;
    Returns a set with the elements in this stream.

    :return: the set of elements in this stream
    &#39;&#39;&#39;
    return set(self.iterable)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stream" href="index.html">stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stream.stream.Stream" href="#stream.stream.Stream">Stream</a></code></h4>
<ul class="two-column">
<li><code><a title="stream.stream.Stream.allMatch" href="#stream.stream.Stream.allMatch">allMatch</a></code></li>
<li><code><a title="stream.stream.Stream.anyMatch" href="#stream.stream.Stream.anyMatch">anyMatch</a></code></li>
<li><code><a title="stream.stream.Stream.concat" href="#stream.stream.Stream.concat">concat</a></code></li>
<li><code><a title="stream.stream.Stream.constant" href="#stream.stream.Stream.constant">constant</a></code></li>
<li><code><a title="stream.stream.Stream.count" href="#stream.stream.Stream.count">count</a></code></li>
<li><code><a title="stream.stream.Stream.distinct" href="#stream.stream.Stream.distinct">distinct</a></code></li>
<li><code><a title="stream.stream.Stream.dropWhile" href="#stream.stream.Stream.dropWhile">dropWhile</a></code></li>
<li><code><a title="stream.stream.Stream.empty" href="#stream.stream.Stream.empty">empty</a></code></li>
<li><code><a title="stream.stream.Stream.filter" href="#stream.stream.Stream.filter">filter</a></code></li>
<li><code><a title="stream.stream.Stream.findAny" href="#stream.stream.Stream.findAny">findAny</a></code></li>
<li><code><a title="stream.stream.Stream.findFirst" href="#stream.stream.Stream.findFirst">findFirst</a></code></li>
<li><code><a title="stream.stream.Stream.flatMap" href="#stream.stream.Stream.flatMap">flatMap</a></code></li>
<li><code><a title="stream.stream.Stream.forEach" href="#stream.stream.Stream.forEach">forEach</a></code></li>
<li><code><a title="stream.stream.Stream.generate" href="#stream.stream.Stream.generate">generate</a></code></li>
<li><code><a title="stream.stream.Stream.iterate" href="#stream.stream.Stream.iterate">iterate</a></code></li>
<li><code><a title="stream.stream.Stream.limit" href="#stream.stream.Stream.limit">limit</a></code></li>
<li><code><a title="stream.stream.Stream.map" href="#stream.stream.Stream.map">map</a></code></li>
<li><code><a title="stream.stream.Stream.max" href="#stream.stream.Stream.max">max</a></code></li>
<li><code><a title="stream.stream.Stream.min" href="#stream.stream.Stream.min">min</a></code></li>
<li><code><a title="stream.stream.Stream.noneMatch" href="#stream.stream.Stream.noneMatch">noneMatch</a></code></li>
<li><code><a title="stream.stream.Stream.of" href="#stream.stream.Stream.of">of</a></code></li>
<li><code><a title="stream.stream.Stream.ofNullable" href="#stream.stream.Stream.ofNullable">ofNullable</a></code></li>
<li><code><a title="stream.stream.Stream.peek" href="#stream.stream.Stream.peek">peek</a></code></li>
<li><code><a title="stream.stream.Stream.reduce" href="#stream.stream.Stream.reduce">reduce</a></code></li>
<li><code><a title="stream.stream.Stream.skip" href="#stream.stream.Stream.skip">skip</a></code></li>
<li><code><a title="stream.stream.Stream.sorted" href="#stream.stream.Stream.sorted">sorted</a></code></li>
<li><code><a title="stream.stream.Stream.sum" href="#stream.stream.Stream.sum">sum</a></code></li>
<li><code><a title="stream.stream.Stream.takeWhile" href="#stream.stream.Stream.takeWhile">takeWhile</a></code></li>
<li><code><a title="stream.stream.Stream.toBooleanStream" href="#stream.stream.Stream.toBooleanStream">toBooleanStream</a></code></li>
<li><code><a title="stream.stream.Stream.toList" href="#stream.stream.Stream.toList">toList</a></code></li>
<li><code><a title="stream.stream.Stream.toNumberStream" href="#stream.stream.Stream.toNumberStream">toNumberStream</a></code></li>
<li><code><a title="stream.stream.Stream.toSet" href="#stream.stream.Stream.toSet">toSet</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>